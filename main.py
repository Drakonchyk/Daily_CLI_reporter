from collections import defaultdict
from datetime import datetime, timedelta
import requests
import pytz

# Constants for Clockify API
API_TOKEN = 'your_api_token_here'
WORKSPACE_ID = 'your_workspace_id_here'
USER_ID = 'your_user_id_here'

BASE_URL = 'https://api.clockify.me/api/v1'
HEADERS = {
    'X-Api-Key': API_TOKEN,
    'Content-Type': 'application/json'
}

# Set your local timezone here
LOCAL_TIMEZONE = pytz.timezone('Europe/Kyiv')

def get_time_entries():
    """
    Fetches time entries from Clockify API for a specific user in a workspace.
    
    Returns:
        list: Time entries or None if request fails.
    """
    url = f'{BASE_URL}/workspaces/{WORKSPACE_ID}/user/{USER_ID}/time-entries'
    response = requests.get(url, headers=HEADERS)
    
    if response.status_code == 200:
        return response.json()
    else:
        print(f"Error fetching time entries (Status Code: {response.status_code})")
        return None

def generate_report(time_entries):
    """
    Groups the time entries by date and task, preparing a summary report.
    
    Args:
        time_entries (list): List of time entry records.
        
    Returns:
        defaultdict: Report grouped by date and task.
    """
    report = defaultdict(lambda: defaultdict(list))

    for entry in time_entries:
        task_name = entry.get('description', 'Unnamed Task')
        time_interval = entry.get('timeInterval', {})
        start_time_str = time_interval.get('start')
        end_time_str = time_interval.get('end')

        if not start_time_str:
            print(f"Skipping entry due to missing start time: {entry}")
            continue

        try:
            start_time = datetime.fromisoformat(start_time_str[:-1] + '+00:00').astimezone(pytz.utc)
            start_time_local = start_time.astimezone(LOCAL_TIMEZONE)

            if end_time_str:
                end_time = datetime.fromisoformat(end_time_str[:-1] + '+00:00').astimezone(pytz.utc)
                end_time_local = end_time.astimezone(LOCAL_TIMEZONE)
                time_spent = (end_time - start_time).total_seconds()
            else:
                end_time_local = None
                time_spent = None

            report[start_time_local.date()][task_name].append((end_time_local, time_spent))

        except ValueError as e:
            print(f"Error parsing dates for entry {entry}: {e}")

    return report

def format_time(seconds):
    """
    Converts time duration in seconds to HH:MM:SS format.
    
    Args:
        seconds (int): Time in seconds.
        
    Returns:
        str: Time formatted as HH:MM:SS.
    """
    return str(timedelta(seconds=int(seconds)))

def print_report(report):
    """
    Prints the formatted report to the console, grouping by date and task.
    
    Args:
        report (defaultdict): Summary report generated by generate_report function.
    """
    print("Summary Report:")

    for date, tasks in report.items():
        print(f"\nDate: {date}")

        # Flatten and sort tasks by end time (ongoing tasks first)
        flat_tasks = [
            (task, end_time, time_spent) 
            for task, entries in tasks.items() 
            for end_time, time_spent in entries
        ]
        sorted_tasks = sorted(flat_tasks, key=lambda x: x[1] if x[1] else datetime.min)

        for task, end_time, time_spent in sorted_tasks:
            if end_time:
                print(f"\tTask: {task} \n\t- Completed at: {end_time.strftime('%H:%M:%S')} \n\t- Time spent: {format_time(time_spent)}")
            else:
                print(f"\tTask: {task} \n\t- Ongoing \n\t- Time spent: {format_time(time_spent) if time_spent else 'Unknown'}")
            print('\t---')

        total_time_spent = sum([time for _, _, time in flat_tasks if time])
        print(f"Total time spent on {date}: {format_time(total_time_spent)}")

if __name__ == '__main__':
    time_entries = get_time_entries()

    if time_entries:
        report = generate_report(time_entries)
        print_report(report)
